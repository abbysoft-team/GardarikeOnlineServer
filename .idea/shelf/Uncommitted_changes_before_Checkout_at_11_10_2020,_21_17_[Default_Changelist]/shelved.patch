Index: main.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main\n\nimport (\n\tlog \"github.com/sirupsen/logrus\"\n\t\"os\"\n\t\"projectx-server/common\"\n\t\"projectx-server/logic\"\n)\n\nconst (\n\tclientPortBase = 2015\n\tclientsCount   = 5\n\tversion        = \"0.0.3\"\n)\n\nfunc initLogging() {\n\tlog.SetOutput(os.Stdout)\n\tlog.SetLevel(log.DebugLevel)\n}\n\ntype gameServer struct {\n}\n\nfunc main() {\n\tlog.SetLevel(log.DebugLevel)\n\tlog.Printf(\"ProjectX Server v%s\", version)\n\n\tif len(os.Args) < 2 {\n\t\tlog.Fatal(\"Please, specify listen address in first argument\")\n\t}\n\n\tserver, err := NewServer(Config{\n\t\tAddress:        os.Args[1],\n\t\tReadBufferSize: common.MaxPacketSize,\n\t}, logic.NewServerLogic(logic.NewSimplexMapGenerator(5, 1.5)))\n\n\tif err != nil {\n\t\tlog.WithError(err).Fatalf(\"Failed to start server on %s\", os.Args[1])\n\t}\n\n\tserver.Serve()\n}\n\nfunc startTestClient(serverAddress string, clientAddress string) {\n\tclient, err := NewClient(ClientConfig{\n\t\tListenAddress: clientAddress,\n\t\tServerAddress: serverAddress,\n\t})\n\tif err != nil {\n\t\tlog.WithError(err).Error(\"Failed to start client\")\n\t\treturn\n\t}\n\n\tclient.Serve()\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- a/main.go	(revision 5385a9095ace10d743ecf1b36075e038010456fc)
+++ b/main.go	(date 1602419930903)
@@ -38,6 +38,8 @@
 		log.WithError(err).Fatalf("Failed to start server on %s", os.Args[1])
 	}
 
+	//go startTestClient("server.abbysoft.org:27015", "0.0.0.0:27016")
+
 	server.Serve()
 }
 
Index: client.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/golang/protobuf/proto\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"net\"\n\t\"projectx-server/common\"\n\trpc \"projectx-server/rpc/generated\"\n\t\"time\"\n)\n\ntype Client struct {\n\tsocket        *net.UDPConn\n\tlistenAddress *net.UDPAddr\n\tserverAddress *net.UDPAddr\n\tlogger        *log.Entry\n}\n\ntype ClientConfig struct {\n\tListenAddress string\n\tServerAddress string\n}\n\nfunc NewClient(config ClientConfig) (*Client, error) {\n\tlistenAddress, err := net.ResolveUDPAddr(\"udp\", config.ListenAddress)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to resolve listen address: %w\", err)\n\t}\n\n\tserverAddress, err := net.ResolveUDPAddr(\"udp\", config.ServerAddress)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to resolve server address: %w\", err)\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", listenAddress, serverAddress)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create client socket: %w\", err)\n\t}\n\n\treturn &Client{\n\t\tsocket:        conn,\n\t\tlistenAddress: listenAddress,\n\t\tserverAddress: serverAddress,\n\t\tlogger:        log.WithField(\"module\", \"Client\"),\n\t}, nil\n}\n\nfunc generateRandomRequest() (request rpc.Request) {\n\tif time.Now().Unix()%2 == 0 {\n\t\trequest.Data = &rpc.Request_GetMapRequest{\n\t\t\tGetMapRequest: &rpc.GetMapRequest{\n\t\t\t\tLocation: &rpc.Vector3D{\n\t\t\t\t\tX: 10,\n\t\t\t\t\tY: 15,\n\t\t\t\t\tZ: 20,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t} else {\n\t\trequest.Data = &rpc.Request_LoginRequest{\n\t\t\tLoginRequest: &rpc.LoginRequest{\n\t\t\t\tUsername: \"testCLient\",\n\t\t\t\tPassword: \"password\",\n\t\t\t},\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (c *Client) Serve() {\n\tdefer c.socket.Close()\n\n\tgo c.readResponses()\n\tfor {\n\t\ttime.Sleep(1 * time.Second)\n\n\t\trequest := generateRandomRequest()\n\n\t\tif err, _ := common.WriteResponse(&request, nil, c.socket); err != nil {\n\t\t\tc.logger.WithError(err).Error(\"Failed to write request\")\n\t\t}\n\t}\n}\n\nfunc (c *Client) readResponses() {\n\tvar buffer [1024]byte\n\tfor {\n\t\tbytesRead, err := c.socket.Read(buffer[0:])\n\t\tif err != nil {\n\t\t\tc.logger.WithError(err).Error(\"Failed to read response from the server\")\n\t\t\tcontinue\n\t\t}\n\n\t\tvar response rpc.Response\n\t\tif err := proto.Unmarshal(buffer[0:bytesRead], &response); err != nil {\n\t\t\tc.logger.WithError(err).Error(\"Failed to deserialize server response\")\n\t\t\tcontinue\n\t\t}\n\n\t\tif response.GetMultipartResponse() != nil {\n\t\t\tc.logger.\n\t\t\t\tWithField(\"parts\", response.GetMultipartResponse().Parts).\n\t\t\t\tInfof(\"Server respond with multipart response\")\n\n\t\t\tactualResponse, err := c.readMultipartResponse(int(response.GetMultipartResponse().Parts))\n\t\t\tif err != nil {\n\t\t\t\tc.logger.WithError(err).Error(\"Failed to read multipart response\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tresponse.Data = actualResponse.Data\n\t\t}\n\n\t\tc.logger.\n\t\t\tWithField(\"response\", response.Data).\n\t\t\tInfof(\"Server respond with %d bytes\", bytesRead)\n\t}\n}\n\nfunc (c *Client) readMultipartResponse(parts int) (*rpc.Response, error) {\n\tvar buffer [common.MaxPacketSize]byte\n\tvar resultBuffer []byte\n\n\tfor parts > 0 {\n\t\tbytesRead, err := c.socket.Read(buffer[0:])\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read response from the server\")\n\t\t}\n\n\t\tresultBuffer = append(resultBuffer, buffer[0:bytesRead]...)\n\t\tparts--\n\t}\n\n\tvar response rpc.Response\n\tif err := proto.Unmarshal(resultBuffer, &response); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to serialize response: %v\", err)\n\t}\n\n\treturn &response, nil\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- a/client.go	(revision 5385a9095ace10d743ecf1b36075e038010456fc)
+++ b/client.go	(date 1602343014219)
@@ -47,7 +47,7 @@
 }
 
 func generateRandomRequest() (request rpc.Request) {
-	if time.Now().Unix()%2 == 0 {
+	if time.Now().UnixNano() % 2 == 0 {
 		request.Data = &rpc.Request_GetMapRequest{
 			GetMapRequest: &rpc.GetMapRequest{
 				Location: &rpc.Vector3D{
@@ -74,13 +74,13 @@
 
 	go c.readResponses()
 	for {
-		time.Sleep(1 * time.Second)
-
 		request := generateRandomRequest()
-
 		if err, _ := common.WriteResponse(&request, nil, c.socket); err != nil {
 			c.logger.WithError(err).Error("Failed to write request")
 		}
+
+		c.logger.Debugf("Request %T sent to the server", request.Data)
+		time.Sleep(10 * time.Second)
 	}
 }
 
Index: .circleci/images/Dockerfile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>FROM golang:1.15\n\nRUN apt-get update && apt-get install -y protobuf-compiler
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- a/.circleci/images/Dockerfile	(revision 5385a9095ace10d743ecf1b36075e038010456fc)
+++ b/.circleci/images/Dockerfile	(date 1602184198517)
@@ -1,3 +1,4 @@
 FROM golang:1.15
 
-RUN apt-get update && apt-get install -y protobuf-compiler
\ No newline at end of file
+RUN apt-get update && apt-get install -y protobuf-compiler
+RUN go get -u github.com/golang/protobuf/protoc-gen-go
